\documentclass[10pt]{article}

\usepackage{henrian-basic}
\usepackage{henrian-homework}

\newcommand{\rinline}[1]{SOMETHING WRONG WITH KNITR}
%% begin.rcode setup, include=FALSE
opts_chunk$set(fig.path='hw03-fig/latex-', cache.path='hw03-cache/latex-', echo=FALSE,
  fig.align='center', fig.width=7, fig.height=4, out.width='.95\\linewidth', size='small')#$
fmtmean = function(xs) { sprintf('%.3f', mean(xs)) }
library(ggplot2)
%% end.rcode

% R working directory: /Users/chbrown/Dropbox/ut/nlp/homework/reports
% setwd('/Users/chbrown/Dropbox/ut/nlp/homework/reports')

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{cancel}
\usepackage{float}
\usepackage{booktabs}
\usepackage[bottom]{footmisc}

\usepackage{beramono}
\usepackage{listings}
\lstset{basicstyle=\ttfamily}

\usepackage{natbib}
\bibliographystyle{plainnat}
\bibpunct{(}{)}{,}{a}{,}{,}

\makeHeaders{NLP: Homework 3}

\begin{document}

\section{Active Learning}

A common scenario in natural language processing is having far more data than annotations, since data collection is easy and annotation is hard.
Two common techniques for making the best of this imbalance are semi-supervised learning and active learning. This report focuses on active learning; in this particular scenario, `active learning' simply means using prior annotations to select which unlabeled sentences would be most useful to annotate.

We find that active learning, particularly using the `tree entropy' metric, significantly boosts the usefulness of additional annotations.

Active learning is most useful at the very beginning of the learning process. At this point, the difference between a random sample of the unlabeled data (potential annotations) and a heuristically selected sample is the greatest. However, we are using a limited pool of unlabeled data (which is somewhat realistic; we will rarely annotate all of the data we have on hand). As we use more and more of the unlabeled data, the difference decreases until we reach the final batch of $\sim 60$ sentences, at which point the heuristic selection function must select the same sentences as the random function, since that's all there is left.

\section{Comparison between heuristics}

We used three heuristics to select unlabeled sentences to `annotate' (of course, we did not annotate any sentences, we merely allowed ourselves to see the pre-existing annotations for certain sentences). The goal is to minimize annotation costs; we approximate that by trying to minimize the number of sentences we train on. It's debatable whether annotation costs are most directly related to token counts. Particularly if the sentences are preprocessed in some naive way (as the Penn treebank was), there might be other factors more important than token counts---aspects of verifying and completing a parse that make some sentence more costly than another.

\begin{enumerate}
  \item \textbf{Tree entropy.} By measuring the distribution of trees and the confidence of the parser, we can select sentences that the parser is clueless about. If the parser thinks each of 20 trees are nearly equally probable, tree entropy will very high; if it vastly prefers a single parse to all the others, tree entropy will be low. We select those sentences where the parser produces high entropy, because those will presumably be most instructive.
  \item \textbf{Top parse.} The parser assigns a probability to the highest parse in a sentence, relative to other potential parses. This is not directly related to such probabilities measured for other sentences, but by normalizing for sentence length, we can facilitate a crude comparison.
  \item \textbf{Length.} Longer sentences will have more complex parses, which are presumably more instructive.
\end{enumerate}

We compare these to an incremental learner that randomly selects a number of new sentences to annotate from the unlabeled pool.



As expected, the random selection function is the weakest at the beginning. The tree entropy measure is the best, followed by the length-normalized best parse, and then the sentence length.


\section{Semisupervised}

I also tried training the parser on it's own parses; I had the parser re-annotate the unlabeled sentences and then learn from those. This was not at all what the parser was built to do, but surprisingly, this was marginally helpful.
I used the same selection functions, but sometimes in different order; for example, I had it learn from the sentences with the lowest tree entropy, i.e., those sentences for which it was most confident in the best parse.

%% begin.rcode 'reparse-plots', cached=TRUE
tab = read.csv('hw03-reparse_after_50.csv')

ggplot(tab, aes(x=iteration, y=f1, colour=selection, linetype=selection)) + geom_path() +
  ylab("PCFG F1 Score") + xlab("Iteration")
%% end.rcode


\section{Conclusion}


\subsection*{Ideas for improvements}

In a truly active learning situation, we could construct the parser to gauge the most useful-to-annotate subtrees; our parser could determine what part of a tree it is highly confident about, and then present those parts of the tree to the annotator cemented together, leaving only the unconfident structure for the annotate to fill in.



\subsection{Instructions}

\begin{itemize}
  \item All code and full SBT project, is available at \url{https://github.com/chbrown/nlp.git}.
  \item Commands used to run the code can be found in \texttt{hw03.README}.
  \item I made considerable changes to the Stanford Parser source code because it was emitting a huge number of logging messages and does not allow setting the log level. I was able to silence some of the messages via a custom TreebankLangParserParams class with pw() method overrides, but there were still far too many System.err's hard-coded into the Stanford Parser source. With all the jars that the library requires, I'm left with about 80 MB of free disk space on the CS cluster (which isn't too surprising considering I only have 256 MB to begin with). The Stanford parser quickly burned through that legroom with all the forcibly logged parse trees and parameters displays. So I replaced many of the forced standard error calls with log4j rootLogger.trace calls, which brought the library's output down to a much more reasonable level.
\end{itemize}

\end{document}

[4] Using the ParserDemo.java class as a example, develop a simple command line interface to the LexicalizedParser that includes support for active learning. Your package should train a parser on a given training set and evaluate it on a given test set, as with the bundled LexicalizedParser. Additionally, choose a random set of sentences from the "unlabeled" training pool whose word count totals approximately 1500 (this represents approximately 60 additional sentences of average length). Output the original training set plus the annotated versions of the randomly selected sentences as your next training set. Output the remaining "unlabeled" training instances as your next "unlabeled" training pool. Lastly, collect your results for this iteration, including at a minimum the following:

      Iteration number
      Number of training words
      The sample selection function
      PCFG F1 score

[5] Execute 10-20 iterations of your parser for the random selection function, selecting approx 1500 words of additional training data each iteration. You may wish to write a simple test harness script that automates this for you. The random selection function represents a baseline that your more sophisticated sample selection functions should outperform.

[6] Implement the three selection functions describe above (sentence length, normalized probability of the top parse, and tree entropy using the top 10-20 PCFG parses), use each of them to replace random selection in the previous run, and collect results for each. Make sure to collect enough data to plot a learning curve (F1 score versus number of training words) for each sample selection function. Note: if you are sorting by a function that is difficult or costly to compute (such as those requiring parsing of sentences), you may want to compute its value for each instance and cache those values to avoid costly re-parsing.

[7] (Optional) If you have additional time, you may wish to experiment by changing the batch size, initial training set size, or the size of the unlabeled training set.

[Report]

Your hard-copy report (of approximately 4-6 pages) should contain a concise but detailed discussion of the experiments you ran, including nicely formatted learning curves presenting the results. In your discussion, be sure to address at least the following questions:

    Do the active learning methods perform better than random selection of training examples? Why?
    Does active learning help across the complete learning curve, or are there parts of the learning curve where it performs best? Why?
    How do the different methods for measuring uncertainty perform compared to each other? Which ones seem to work best? Try to explain any observed differences between methods.
    How do your results compare to those presented by Hwa (2000)?
